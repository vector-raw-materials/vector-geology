
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/03_forward_engines/01_gravity_gradiometry_inversion_pgi.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_examples_03_forward_engines_01_gravity_gradiometry_inversion_pgi.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_03_forward_engines_01_gravity_gradiometry_inversion_pgi.py:


Inversion of Gravity Gradiometry Data on a Tree Mesh
----------------------------------------------------

We use the PGI module within SimPEG to invert gravity gradiometry data on a Tree Mesh. This tutorial focusses on:

    - How to define all the necessary components
    - How to initialize the Gaussian Mixture Model Prior
    - How to set the parameters
    - How to plot the results

.. GENERATED FROM PYTHON SOURCE LINES 16-17

## Import Modules

.. GENERATED FROM PYTHON SOURCE LINES 17-69

.. code-block:: default


    import discretize as ds
    import SimPEG.potential_fields as pf
    from SimPEG import (
        maps,
        data,
        utils,
        simulation,
        inverse_problem,
        inversion,
        optimization,
        regularization,
        data_misfit,
        directives,
    )
    from SimPEG.utils import io_utils
    import numpy as np
    import pandas as pd
    import scipy.interpolate as interp
    import matplotlib as mpl
    import matplotlib.pyplot as plt
    import math as math

    from dotenv import dotenv_values
    from mpl_toolkits.axes_grid1.inset_locator import inset_axes

    from discretize.utils import mkvc, refine_tree_xyz, active_from_xyz
    from discretize import TensorMesh, TreeMesh
    from SimPEG.utils import plot2Ddata, model_builder, surface2ind_topo
    from SimPEG import maps
    from SimPEG.potential_fields import magnetics as mag
    from SimPEG.potential_fields import gravity as grav
    import os
    import shutil
    from vector_geology import SimpegHelper as SH

    #from get_cpt import get_cmap

    # Plot beautification

    formatter = mpl.ticker.ScalarFormatter(useMathText=True)
    formatter.set_scientific(True)
    formatter.set_powerlimits((0,0))

    mpl.rc("axes", titlesize=14, labelsize=12)
    mpl.rc("xtick", labelsize=12)
    mpl.rc("ytick", labelsize=12)

    # Reproducible science
    np.random.seed(518936)









.. GENERATED FROM PYTHON SOURCE LINES 70-71

Create directories for the model iterations and output

.. GENERATED FROM PYTHON SOURCE LINES 71-92

.. code-block:: default


    # Name of the model
    name = "Ireland_FTG_NonNeg"
    # Names for the directories for the model iterations and output
    path_to_mod_iterations = "./" + str(name) + "/Model Iterations"
    path_to_output = "./" + str(name) + "/Output"

    # Check if the model iterations directory exists and remove it if it does
    if os.path.exists(path_to_mod_iterations):
        shutil.rmtree(path_to_mod_iterations)

    # Create the model iterations directory.
    os.makedirs(path_to_mod_iterations)

    # Check if the output directory exists and remove it if it does
    if os.path.exists(path_to_output):
        shutil.rmtree(path_to_output)

    # Create the output directory.
    os.makedirs(path_to_output)








.. GENERATED FROM PYTHON SOURCE LINES 93-98

Load the data
Read gravity and magnetic data from a csv file.
Inputs:
file_path: The path to the csv file.
header: Whether or not the csv file has a header row.

.. GENERATED FROM PYTHON SOURCE LINES 98-120

.. code-block:: default



    config = dotenv_values()
    file_path = config.get("PATH_TO_GRADIOMETRY")

    header = None

    # Read the csv file into a pandas dataframe and then convert it to a numpy array.
    FTG_Data = pd.read_csv(file_path, delimiter=",").to_numpy()

    # Add Topography
    FTG_Data = np.c_[FTG_Data, np.zeros(np.shape(FTG_Data)[0])]
    FTG_Data[:,[2, -1]] = FTG_Data[:,[-1, 2]]

    # Format after adding topography
    # X, Y, Z, Tyy, Txz, Tyz, Txy, Txx


    ## %
    ## Resample the data
    # The ``SimpegHelper.pf_rs()`` will take in potential field data and resample it onto a new regular grid








.. GENERATED FROM PYTHON SOURCE LINES 121-122

New sampling interval (Data Units)

.. GENERATED FROM PYTHON SOURCE LINES 122-142

.. code-block:: default

    inc = 200

    # Resample the data
    [grav_new, nx_new, ny_new] = SH.pf_rs(FTG_Data, inc)

    # Extract the gravity gradiometry data vectors
    grav_vec = grav_new[:,3:]

    # Negate the gravity data to the opposite sign to match the coordinate system.
    # NOTE: This step is necessary for real data since the convention followed by
    # the SimPEG forward operator gravity lows over density highs.
    # grav_vec = -grav_vec

    # Extract the topography for the active cells.
    inv_topo = grav_new[:,[0,1,2]]


    ## Visualize the data

    #The ``SimpegHelper.plot_2D_data()`` function will plot the datasets using ``matplotlib``.







.. GENERATED FROM PYTHON SOURCE LINES 143-144

Plot Gravity Data

.. GENERATED FROM PYTHON SOURCE LINES 144-148

.. code-block:: default

    SH.plot_2D_data(np.c_[grav_new[:,[0,1,2]], grav_vec[:,-1]], [np.nanmin(grav_vec[:,-1]), np.nanmax(grav_vec[:,-1])], cmap="jet", path_to_output=path_to_output, name=name)

    # Plot Topography Data
    # SH.plot_2D_data(np.c_[inv_topo[:,[0,1,2]], inv_topo[:,2]], [np.nanmin(inv_topo[:,2]), np.nanmax(inv_topo[:,2])], which_data="Topo", cmap="magma", path_to_output=path_to_output, name=name)



.. image-sg:: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_001.png
   :alt: Gravity Anomaly
   :srcset: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 149-150

# Create a TreeMesh object to invert the data

.. GENERATED FROM PYTHON SOURCE LINES 150-152

.. code-block:: default


    # Using the ``discretize.TreeMesh`` utility, create a 3D TreeMesh to invert the gravity gradiometry data.







.. GENERATED FROM PYTHON SOURCE LINES 153-193

.. code-block:: default

    dx = inc
    dy = inc
    dz = 10
    nz_core = 1
    nz_pad = 20
    fact = 1.1

    # Set the cell sizes to a constant value in the x and y directions and expanding in the z direction.
    inv_hx = dx * np.ones(nx_new)
    inv_hy = dy * np.ones(ny_new)
    inv_hz = [(dz, nz_pad, -fact), (dz, nz_core), (dz, nz_pad, fact)]

    # Create the inverse tensor mesh.
    inv_mesh = ds.TensorMesh([inv_hx, inv_hy, inv_hz], x0=[np.min(inv_topo[:,0]), np.min(inv_topo[:,1]), "C"])

    # Drape the topography over the mesh
    actv = active_from_xyz(inv_mesh, inv_topo)
    ndv = np.nan
    actvMap = maps.InjectActiveCells(inv_mesh, actv, ndv)
    nactv = int(actv.sum())

    # Make an x-y grid with the mesh cell centers
    # xygrid = np.meshgrid(inv_mesh.cell_centers_x, inv_mesh.cell_centers_y)
    # xygrid = np.reshape(xygrid, (2,-1)).T

    # Region Active Array (bool array with the spatial extent of the data)
    # RegActvArr = np.empty((len(xygrid)), dtype=bool)

    # for i in range(len(xygrid)):
    #     Dist = np.sqrt(np.sum((inv_topo[:, [0, 1]] - xygrid[i,:])**2, axis=1))
    #     MinDist = np.min(Dist)
    #     RegActvArr[i] = MinDist < 50

    # Repeating the regional active array for every z (since we only carried out the calculations for x-y, which can be replicated in z)
    # RegActvArr = np.tile(RegActvArr, len(inv_mesh.cell_centers_z))

    # Intersection between Topo active cells and spatial active cells (nactv and actvMap are also updated)
    actv = actv
    nactv = int(actv.sum())
    actvMap = maps.InjectActiveCells(inv_mesh, actv, ndv)







.. GENERATED FROM PYTHON SOURCE LINES 194-195

.. code-block:: default

    inv_mesh





.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <table>
      <tr>
        <td style='font-weight: bold; font-size: 1.2em; text-align: center;' colspan='3'>TensorMesh</td>
        <td style='font-size: 1.2em; text-align: center;'colspan='4'>111,930 cells</td>
      </tr>
      <tr>
        <th></th>
        <th></th>
        <th colspan='2' style='padding: 5px 20px 5px 20px;'>MESH EXTENT</th>
        <th colspan='2' style='padding: 5px 20px 5px 20px;'>CELL WIDTH</th>
        <th style='padding: 5px 20px 5px 20px;'>FACTOR</th>
      </tr>
      <tr>
        <th style='padding: 5px 20px 5px 20px;'>dir</th>
        <th style='padding: 5px 20px 5px 20px;'>nC</th>
        <th style='padding: 5px 20px 5px 20px;'>min</th>
        <th style='padding: 5px 20px 5px 20px;'>max</th>
        <th style='padding: 5px 20px 5px 20px;'>min</th>
        <th style='padding: 5px 20px 5px 20px;'>max</th>
        <th style='padding: 5px 20px 5px 20px;'>max</th>
      </tr>
      <tr>
        <td style='padding: 5px 20px 5px 20px;'>x</td>
        <td style='padding: 5px 20px 5px 20px;'>78</td>
        <td style='padding: 5px 20px 5px 20px;'>155,500.00</td>
        <td style='padding: 5px 20px 5px 20px;'>171,100.00</td>
        <td style='padding: 5px 20px 5px 20px;'>200.00</td>
        <td style='padding: 5px 20px 5px 20px;'>200.00</td>
        <td style='padding: 5px 20px 5px 20px;'>1.00</td>
      </tr>
      <tr>
        <td style='padding: 5px 20px 5px 20px;'>y</td>
        <td style='padding: 5px 20px 5px 20px;'>35</td>
        <td style='padding: 5px 20px 5px 20px;'>142,500.00</td>
        <td style='padding: 5px 20px 5px 20px;'>149,500.00</td>
        <td style='padding: 5px 20px 5px 20px;'>200.00</td>
        <td style='padding: 5px 20px 5px 20px;'>200.00</td>
        <td style='padding: 5px 20px 5px 20px;'>1.00</td>
      </tr>
      <tr>
        <td style='padding: 5px 20px 5px 20px;'>z</td>
        <td style='padding: 5px 20px 5px 20px;'>41</td>
        <td style='padding: 5px 20px 5px 20px;'>-635.02</td>
        <td style='padding: 5px 20px 5px 20px;'>635.02</td>
        <td style='padding: 5px 20px 5px 20px;'>10.00</td>
        <td style='padding: 5px 20px 5px 20px;'>67.27</td>
        <td style='padding: 5px 20px 5px 20px;'>1.10</td>
      </tr>
    </table>

    </div>
    <br />
    <br />

.. GENERATED FROM PYTHON SOURCE LINES 196-197

# Visualize the mesh

.. GENERATED FROM PYTHON SOURCE LINES 197-199

.. code-block:: default


    #The ``discretize.TreeMesh.plot_slice()`` utility will plot a slice of thee Tree Mesh object generated above.







.. GENERATED FROM PYTHON SOURCE LINES 200-202

Plotting a mesh slice
Create a background model.

.. GENERATED FROM PYTHON SOURCE LINES 202-219

.. code-block:: default

    bg = np.ones(nactv)
    mod = actvMap * bg

    # Define the tensor mesh parameters.
    props = dict(boxstyle='round,pad=1', facecolor='white')

    # Plot the mesh slice.
    fig = plt.figure(figsize=(6, 6))
    ax = fig.add_axes([0.1, 0.1, 0.8, 0.8])
    cplot = inv_mesh.plot_slice(mod, grid=False, ax=ax, normal="Y", ind=22)
    ax.set_title('Tensor Mesh Slice')
    ax.set_xlabel('x (m)')
    ax.set_ylabel('y (m)')
    ax.ticklabel_format(axis="both")
    ax.set_aspect('equal')
    plt.savefig(path_to_output + "/" + name + "_TreeMeshSlice.pdf", bbox_inches="tight")
    plt.show()



.. image-sg:: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_002.png
   :alt: Tensor Mesh Slice
   :srcset: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_002.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 220-223

# Set up the gravity inverse problem
%%
 Create wires for the density model

.. GENERATED FROM PYTHON SOURCE LINES 223-266

.. code-block:: default

    wires = maps.Wires(("density", nactv))

    # Create a Density Mapping
    density_map = actvMap * wires.density
    # Create Identity Mapping
    identity_map = maps.IdentityMap(nP=nactv)

    # Components of the data used as input
    gravity_components = ["gyy", "gxz", "gyz", "gxy", "gxx"]

    # Receiver locations
    gravity_receiver_locations = grav_new[:, [0, 1, 2]]

    # Create a gravity receiver list
    gravity_receivers = pf.gravity.receivers.Point(gravity_receiver_locations, components=gravity_components)
    gravity_receiver_list = [gravity_receivers]

    # Create a gravity source field
    gravity_source_field = pf.gravity.sources.SourceField(receiver_list=gravity_receiver_list)

    # Define the gravity survey
    gravity_survey = pf.gravity.survey.Survey(gravity_source_field)

    # Set up the gravity simulation problem
    gravity_problem = grav.simulation.Simulation3DIntegral(
        inv_mesh,
        survey=gravity_survey,
        rhoMap=wires.density,
        ind_active=actv
    )

    # Define uncertainties
    # Maximum value of each component
    # max_gravity = np.max(np.abs(grav_vec), axis=0)
    # Standard deviation of each component
    # std_gravity = 0.05 * max_gravity
    # std_gravity = np.ones(np.shape(grav_vec)) * std_gravity

    # Create a gravity data object
    gravity_data = data.Data(gravity_survey, dobs=grav_vec.flatten(), noise_floor=5, relative_error=0.1)

    # Define the misfits associated with the gravity data
    gravity_misfit = data_misfit.L2DataMisfit(data=gravity_data, simulation=gravity_problem)







.. GENERATED FROM PYTHON SOURCE LINES 267-271

# Set up the Gaussian Mixture Model (GMM) Prior
%%
 Defining the Gaussian Mixture Model (GMM)
 Number of rock units and number of physical properties

.. GENERATED FROM PYTHON SOURCE LINES 271-317

.. code-block:: default

    num_rock_units = 5
    num_physical_props = 1

    # Create a weighted Gaussian mixture model with specified parameters
    gmmref = utils.WeightedGaussianMixture(
        n_components=num_rock_units,
        mesh=inv_mesh,
        actv=actv,
        covariance_type="full",
    )

    # Set the background density
    background_density = 0.0

    # Initialize the GMM fit with random samples, mesh size, and number of physical properties
    gmmref.fit(np.random.randn(nactv, num_physical_props))

    # Set the mean values of physical property contrasts for each rock unit
    # One value (density) for each rock unit
    gmmref.means_ = np.c_[
        [-0.4],
        [-0.2],
        [0.0],
        [0.2],
        [0.4],
    ].T

    # Set the original variance for density
    density_variance = 8e-5

    # Set the covariances of physical properties for each rock unit
    gmmref.covariances_ = np.array(
        [
            [[density_variance]],
            [[density_variance]],
            [[density_variance]],
            [[density_variance]],
            [[density_variance]]
        ]
    )

    # Compute the precision (inverse covariance) of each cluster
    gmmref.compute_clusters_precisions()

    # Set the weights for each rock unit
    gmmref.weights_ = np.ones((nactv, 1)) * np.c_[0.125, 0.125, 0.5, 0.125, 0.125]







.. GENERATED FROM PYTHON SOURCE LINES 318-319

GMM Parameters

.. GENERATED FROM PYTHON SOURCE LINES 319-334

.. code-block:: default

    means_init = gmmref.means_.flatten()
    covariances_init = gmmref.covariances_.flatten()
    weights_init = gmmref.weights_[0].flatten()

    # Plot the 1D GMM
    fig = plt.figure(figsize=(6, 6))
    ax = gmmref.plot_pdf(flag2d=False, plotting_precision=1000, padding=0.2)
    ax[0].set_xlabel(r"Density Contrast (g/cc)")
    ax[0].set_ylabel(r"Probability Density Values")
    ax[0].get_legend().remove()
    ax[0].set_title(r"Initial DelRho Distribution")
    ax[0].ticklabel_format(axis="both", style="scientific", scilimits=(0, 0))
    ax[0].set_aspect(1/20)
    plt.savefig(path_to_output + "/" + name + "_Init_GMM.pdf", bbox_inches="tight")
    plt.show()



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_003.png
         :alt: 01 gravity gradiometry inversion pgi
         :srcset: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_004.png
         :alt: Initial DelRho Distribution
         :srcset: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_004.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 335-338

# Define the inversion parameters
%%
 Initial Model

.. GENERATED FROM PYTHON SOURCE LINES 338-436

.. code-block:: default

    initial_model = np.r_[background_density * np.ones(actvMap.nP)]

    # Sensitivity weighting
    # Compute the sensitivity weights for each cell based on the gravity problem's sensitivity matrix (G)
    # This is done by computing the square root of the sum of the squared elements of G for each cell,
    # and then normalizing by the cell volumes and the maximum weight value.
    sensitivity_weights_gravity = np.sum(gravity_problem.G ** 2.0, axis=0) ** 0.5 / (inv_mesh.cell_volumes[actv])
    sensitivity_weights_gravity = sensitivity_weights_gravity / np.nanmax(sensitivity_weights_gravity)

    # Regularization multipliers
    smallness_multiplier = 1e-4
    smoothness_x_multiplier = 1e-1
    smoothness_y_multiplier = 1e-1
    smoothness_z_multiplier = 1e-1

    # Create joint PGI regularization with smoothness
    regularization_term = regularization.PGI(
        gmmref=gmmref,
        mesh=inv_mesh,
        wiresmap=wires,
        maplist=[identity_map],
        active_cells=actv,
        alpha_pgi=smallness_multiplier,
        alpha_x=smoothness_x_multiplier,
        alpha_y=smoothness_y_multiplier,
        alpha_z=smoothness_z_multiplier,
        alpha_xx=0.0,
        alpha_yy=0.0,
        alpha_zz=0.0,
        weights_list=[sensitivity_weights_gravity]
    )

    # Directives for inversion
    # Define the directives for the inversion process, based on Astic et al., (2021)

    # Estimate smoothness multipliers
    alphas_directive = directives.AlphasSmoothEstimate_ByEig(verbose=True)

    # Initialize beta and beta/alpha_s schedule
    beta_directive = directives.BetaEstimate_ByEig(beta0_ratio=1e-2)
    beta_schedule = directives.PGI_BetaAlphaSchedule(
        coolingFactor=16.0,
        tolerance=0.2,
        progress=0.2,
        verbose=True,
    )

    # Define target misfits for geophysical and petrophysical data
    target_misfits = directives.MultiTargetMisfits(verbose=True)

    # Add reference model once stable
    mref_in_smooth = directives.PGI_AddMrefInSmooth(wait_till_stable=True, verbose=True)

    # Update smallness parameters, keeping GMM fixed (L2 Approx of PGI)
    update_smallness_directive = directives.PGI_UpdateParameters(
        update_gmm=True,
        kappa = 0,
        nu = 0.5,
        zeta = 0
    )

    # Update preconditioner
    update_preconditioner = directives.UpdatePreconditioner()

    # Save iteration results
    save_iteration_directive = directives.SaveOutputEveryIteration(name=name, directory=path_to_output)

    # Save model iterations
    save_model_directive = directives.SaveModelEveryIteration(name=name, directory=path_to_mod_iterations)

    # Optimization options for the inversion
    lower_bound = np.r_[-1 * np.ones(actvMap.nP)]
    upper_bound = np.r_[1 * np.ones(actvMap.nP)]
    optimizer = optimization.ProjectedGNCG(
        maxIter=20,
        lower=lower_bound,
        upper=upper_bound,
        maxIterLS=20,
        maxIterCG=100,
        tolCG=1e-4,
    )

    # Inverse problem setup
    inverse_prob = inverse_problem.BaseInvProblem(gravity_misfit, regularization_term, optimizer)
    inversion_algo = inversion.BaseInversion(
        inverse_prob,
        directiveList=[
            alphas_directive,
            beta_directive,
            update_smallness_directive,
            target_misfits,
            beta_schedule,
            mref_in_smooth,
            update_preconditioner,
            save_iteration_directive,
            save_model_directive
        ],
    )







.. GENERATED FROM PYTHON SOURCE LINES 437-440

# Run the Inversion!
%%
 Run the inversion

.. GENERATED FROM PYTHON SOURCE LINES 440-441

.. code-block:: default

    inverted_model = inversion_algo.run(initial_model)




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    SimPEG.InvProblem will set Regularization.reference_model to m0.
    SimPEG.InvProblem will set Regularization.reference_model to m0.

                        SimPEG.InvProblem is setting bfgsH0 to the inverse of the eval2Deriv.
                        ***Done using the default solver SolverLU and no solver_opts.***
                    
    Alpha scales: [13303597.345293514, 0.0, 13291291.128584256, 0.0, 96004.25899069471, 0.0]
    <class 'SimPEG.regularization.pgi.PGIsmallness'>
    SimPEG.SaveOutputEveryIteration will save your inversion progress as: '###-Ireland_FTG_NonNeg-2023-12-14-16-07.txt'
    SimPEG.SaveModelEveryIteration will save your models as: './Ireland_FTG_NonNeg/Model Iterations/###-Ireland_FTG_NonNeg-2023-12-14-16-07.npy'
    model has any nan: 0
    =============================== Projected GNCG ===============================
      #     beta     phi_d     phi_m       f      |proj(x-g)-x|  LS    Comment   
    -----------------------------------------------------------------------------
    x0 has any nan: 0
       0  3.79e-08  1.59e+04  0.00e+00  1.59e+04    2.06e+02      0              
    geophys. misfits: 6396.9 (target 6825.0 [True]) | smallness misfit: 31833.0 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [6396.9]; minimum progress targets: [12694.7]
    Warming alpha_pgi to favor clustering:  0.00010669177094483827
    mref changed in  29837  places
       1  3.79e-08  6.40e+03  1.12e+10  6.82e+03    1.64e+02      0              
    geophys. misfits: 3443.7 (target 6825.0 [True]) | smallness misfit: 32765.9 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3443.7]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.00021145111553427776
    mref changed in  14173  places
       2  3.79e-08  3.44e+03  1.09e+10  3.86e+03    6.78e+01      0              
    geophys. misfits: 3443.1 (target 6825.0 [True]) | smallness misfit: 32692.5 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3443.1]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.0004191377804309684
    mref changed in  2336  places
       3  3.79e-08  3.44e+03  1.08e+10  3.85e+03    5.91e+01      2   Skip BFGS  
    geophys. misfits: 3434.6 (target 6825.0 [True]) | smallness misfit: 32301.7 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3434.6]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.0008328763975470134
    mref changed in  9637  places
       4  3.79e-08  3.43e+03  1.09e+10  3.85e+03    7.63e+01      0              
    geophys. misfits: 3410.0 (target 6825.0 [True]) | smallness misfit: 32353.0 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3410.]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.001666997423849284
    mref changed in  2304  places
       5  3.79e-08  3.41e+03  1.08e+10  3.82e+03    6.27e+01      1              
    geophys. misfits: 3405.8 (target 6825.0 [True]) | smallness misfit: 32305.6 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3405.8]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.003340537806642481
    mref changed in  548  places
       6  3.79e-08  3.41e+03  1.08e+10  3.82e+03    6.47e+01      3   Skip BFGS  
    geophys. misfits: 3394.3 (target 6825.0 [True]) | smallness misfit: 32227.0 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3394.3]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.006716901289141315
    mref changed in  853  places
       7  3.79e-08  3.39e+03  1.08e+10  3.80e+03    5.97e+01      2   Skip BFGS  
    geophys. misfits: 3379.7 (target 6825.0 [True]) | smallness misfit: 32130.3 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3379.7]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.013563981510234007
    mref changed in  2484  places
       8  3.79e-08  3.38e+03  1.08e+10  3.79e+03    4.83e+01      1   Skip BFGS  
    geophys. misfits: 3375.7 (target 6825.0 [True]) | smallness misfit: 32093.2 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3375.7]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.02742395715929332
    mref changed in  1765  places
       9  3.79e-08  3.38e+03  1.08e+10  3.79e+03    3.75e+01      1   Skip BFGS  
    geophys. misfits: 3375.5 (target 6825.0 [True]) | smallness misfit: 32073.9 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3375.5]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.05544992823765521
    mref changed in  451  places
      10  3.79e-08  3.38e+03  1.08e+10  3.79e+03    3.79e+01      2              
    geophys. misfits: 3366.7 (target 6825.0 [True]) | smallness misfit: 32451.3 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3366.7]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.11240918288836876
    mref changed in  3181  places
      11  3.79e-08  3.37e+03  1.10e+10  3.78e+03    3.36e+01      0   Skip BFGS  
    geophys. misfits: 3365.8 (target 6825.0 [True]) | smallness misfit: 32609.1 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3365.8]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.22793964709919495
    mref changed in  332  places
      12  3.79e-08  3.37e+03  1.12e+10  3.79e+03    3.18e+01      2              
    geophys. misfits: 3366.4 (target 6825.0 [True]) | smallness misfit: 33336.6 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3366.4]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.4621242063572519
    mref changed in  563  places
      13  3.79e-08  3.37e+03  1.16e+10  3.81e+03    2.79e+01      1              
    geophys. misfits: 3366.1 (target 6825.0 [True]) | smallness misfit: 34792.5 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3366.1]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  0.9369936514939342
    mref changed in  471  places
      14  3.79e-08  3.37e+03  1.27e+10  3.85e+03    3.56e+01      1              
    geophys. misfits: 3366.7 (target 6825.0 [True]) | smallness misfit: 34950.6 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3366.7]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  1.8994705672039287
    mref changed in  56  places
      15  3.79e-08  3.37e+03  1.49e+10  3.93e+03    5.04e+01      5   Skip BFGS  
    geophys. misfits: 3384.5 (target 6825.0 [True]) | smallness misfit: 37831.4 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3384.5]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  3.830382755121003
    mref changed in  122  places
      16  3.79e-08  3.38e+03  2.08e+10  4.17e+03    7.88e+01      1              
    geophys. misfits: 3396.2 (target 6825.0 [True]) | smallness misfit: 35625.0 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3396.2]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  7.697450612448777
    mref changed in  431  places
      17  3.79e-08  3.40e+03  3.60e+10  4.76e+03    1.17e+02      0              
    geophys. misfits: 3508.6 (target 6825.0 [True]) | smallness misfit: 30940.9 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3508.6]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  14.973218112151427
    mref changed in  299  places
      18  3.79e-08  3.51e+03  5.79e+10  5.70e+03    1.35e+02      0              
    geophys. misfits: 3692.8 (target 6825.0 [True]) | smallness misfit: 29180.6 (target: 27300.0 [False])
    Beta cooling evaluation: progress: [3692.8]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  27.673539996945806
    mref changed in  231  places
      19  3.79e-08  3.69e+03  9.25e+10  7.20e+03    1.44e+02      0              
    geophys. misfits: 4215.7 (target 6825.0 [True]) | smallness misfit: 26238.4 (target: 27300.0 [True])
    All targets have been reached
    Beta cooling evaluation: progress: [4215.7]; minimum progress targets: [8190.]
    Warming alpha_pgi to favor clustering:  44.80242420960896
    mref changed in  308  places
    ------------------------- STOP! -------------------------
    1 : |fc-fOld| = 0.0000e+00 <= tolF*(1+|f0|) = 1.5869e+03
    0 : |xc-x_last| = 6.4899e+00 <= tolX*(1+|x0|) = 1.0000e-01
    0 : |proj(x-g)-x|    = 1.4333e+02 <= tolG          = 1.0000e-01
    0 : |proj(x-g)-x|    = 1.4333e+02 <= 1e3*eps       = 1.0000e-02
    1 : maxIter   =      20    <= iter          =     20
    ------------------------- DONE! -------------------------




.. GENERATED FROM PYTHON SOURCE LINES 442-470

.. code-block:: default

    set = 1
    save_plots = True

    # Indices of the depth sections
    ind_plot_x = int(len(inv_mesh.cell_centers_x)/6) + 10
    ind_plot_y = int(len(inv_mesh.cell_centers_y)/2)
    ind_plot_z = int(len(inv_mesh.cell_centers_z)/2) - 17

    ind_plot = [ind_plot_x, ind_plot_y, ind_plot_z]

    # Extract the results
    inverted_density_model = density_map * inverted_model
    quasi_geology_model = actvMap * regularization_term.objfcts[0].compute_quasi_geology_model()

    # Plot Density Contrast Model (Z)
    normal = "Z"
    model_to_plot = inverted_density_model
    SH.plot_model_slice(inv_mesh, actv, model_to_plot, normal, ind_plot, [-1, 1], set, sec_loc=True, gdlines=True, which_prop="Den", cmap="Spectral", save_plt=save_plots, path_to_output=path_to_output, name=name)

    # Plot Inverted Model Slices (Y)
    normal = "X"
    model_to_plot = inverted_density_model
    SH.plot_model_slice(inv_mesh, actv, model_to_plot, normal, ind_plot, [-1, 1], set, sec_loc=True, gdlines=True, which_prop="Den", cmap="Spectral", save_plt=save_plots, path_to_output=path_to_output, name=name)

    # Plot Inverted Model Slices (X)
    normal = "Y"
    model_to_plot = inverted_density_model
    SH.plot_model_slice(inv_mesh, actv, model_to_plot, normal, ind_plot, [-1, 1], set, sec_loc=True, gdlines=True, which_prop="Den", cmap="Spectral", save_plt=save_plots, path_to_output=path_to_output, name=name)



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_005.png
         :alt: Inverted Den Model Slice at Z = -4.26E+02 m
         :srcset: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_005.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_006.png
         :alt: Inverted Den Model Slice at X = 1.60E+05 m
         :srcset: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_006.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_007.png
         :alt: Inverted Den Model Slice at Y = 1.46E+05 m
         :srcset: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_007.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 471-472

Updated GMM Parameters

.. GENERATED FROM PYTHON SOURCE LINES 472-490

.. code-block:: default

    learned_mu = regularization_term.objfcts[0].gmm.means_.flatten()
    learned_sigma = regularization_term.objfcts[0].gmm.covariances_.flatten()
    learned_pi = regularization_term.objfcts[0].gmm.weights_[0].flatten()

    # Regularization Parameters
    final_alpha_pgi = regularization_term.alpha_pgi

    # Plot the learned GMM
    fig = plt.figure(figsize=(6,6))
    ax = regularization_term.objfcts[0].gmm.plot_pdf(flag2d=False, plotting_precision=500, padding=0.5)
    ax[0].hist(inverted_density_model[actv], density=True, bins=1000)
    ax[0].set_xlabel(r"Density contrast (g/cc)")
    ax[0].set_ylabel(r"Probability Density Values")
    ax[0].get_legend().remove()
    ax[0].set_title(r"Learned DelRho Distribution")
    ax[0].ticklabel_format(axis="both", style="scientific", scilimits=(0, 0))
    plt.savefig(path_to_output + "/" + name + "_Learned_GMM.pdf", bbox_inches="tight")
    plt.show()



.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_008.png
         :alt: 01 gravity gradiometry inversion pgi
         :srcset: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_008.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_009.png
         :alt: Learned DelRho Distribution
         :srcset: /examples/03_forward_engines/images/sphx_glr_01_gravity_gradiometry_inversion_pgi_009.png
         :class: sphx-glr-multi-img





.. GENERATED FROM PYTHON SOURCE LINES 491-491

sphinx_gallery_thumbnail_number = -4


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 9 minutes  3.455 seconds)


.. _sphx_glr_download_examples_03_forward_engines_01_gravity_gradiometry_inversion_pgi.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example




    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 01_gravity_gradiometry_inversion_pgi.py <01_gravity_gradiometry_inversion_pgi.py>`

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 01_gravity_gradiometry_inversion_pgi.ipynb <01_gravity_gradiometry_inversion_pgi.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
